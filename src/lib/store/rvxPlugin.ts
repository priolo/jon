import { Store, WatchCallback, WatchMsg, Watcher } from "./global"

/**
 * Types of events generated by a WATCH of a STORE
 */
 export enum EVENTS_TYPES {
	ACTION = "action",
	ACTION_SYNC = "action-sync",
	MUTATION = "mutation",
}

/**
 * Groups of CALLBACK per "property name"
 */
 type WatchCallbackGroupByProp = { [nameProp: string]: Set<WatchCallback> }

/**
 * Groups of CALLBACK per STORE
 */
const listeners: Map<Store, WatchCallbackGroupByProp> = new Map()

/**
 * Deliver the event to all registered LISTENERS
 * @param key name of actionmutation
 * @param payload of action/mutator
 */
export function pluginEmit(type: EVENTS_TYPES, store: Store, key: string, payload: any, result: any, subcall: boolean) {

	const msg = { type, store, key, payload, result, subcall } as WatchMsg

	// se non trovo lo store non fare nulla
	if (!listeners.has(store)) return

	const storeActions = listeners.get(store)
	if (!storeActions) return

	const callbacksStoreJolly = storeActions["*"]
	if (callbacksStoreJolly) {
		for (const callback of callbacksStoreJolly) callback(msg)
	}

	// get all callbacks for the store and execute them
	const callbacks = storeActions[key]
	if (!callbacks) return
	for (const callback of callbacks) callback(msg)
}


/**
 * Inserts a WATCHER into JON
 */
export function addWatch({ store, actionName, callback }: Watcher) {

	let storeActions: { [name: string]: Set<WatchCallback> }

	// get or create storeActions
	if (!listeners.has(store)) {
		storeActions = {}
		listeners.set(store, storeActions)
	} else {
		storeActions = listeners.get(store)
	}

	// get or create action
	let callbacks = storeActions[actionName]
	if (!callbacks) {
		callbacks = new Set()
		storeActions[actionName] = callbacks
	}

	callbacks.add(callback)
}

/**
 * Removes a listener from JON
 * if `actionName` is `null` delete all listener of STORE
 * if `callback` is `null` delete all listener of `actionName`
 */
export function removeWatch({ store, actionName, callback }: Watcher): void {

	// if exist get storeActions
	if (!listeners.has(store)) return
	const storeActions = listeners.get(store)
	if (!storeActions) return

	// delete callback from storeActions
	const callbacks = storeActions[actionName]
	if (callbacks && callback) callbacks.delete(callback)

	// if there are no more callbacks for the store, delete the storeActions
	if (!callbacks || callbacks.size === 0 || !callback) {
		delete storeActions[actionName]
	}
	if (Object.keys(storeActions).length === 0 || !actionName) {
		listeners.delete(store)
	}
}