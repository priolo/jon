/**
 * @typedef {import("./rvx").Store} Store
 * @typedef { {type:EVENTS_TYPES, store:Store, key:string, payload:Object, result:Object, subcall:boolean} } WatchMessage
 * @typedef { (msg:WatchMessage)=>void } WatchCallback
 * @typedef { {store:Store, actionName:string, callback:WatchCallback} } Listener
 */

/**
 * Types of events generated by a WATCH of a STORE
 * @readonly @enum {string}
 */
export const EVENTS_TYPES = {
	ACTION: "action",
	ACTION_SYNC: "action-sync",
	MUTATION: "mutation",
	// STORE_ADD: "store-add",
	// STORE_REMOVE: "store-remove",
}

/**
 * the registered LISTENERS
 * @type {Map<Store,Object.<string, Set<WatchCallback>>>}
 */
const listeners = new Map()


/**
 * Deliver the event to all registered LISTENERS
 * @param {EVENTS_TYPES} type 
 * @param {Store} store 
 * @param {string} key name of actionmutation
 * @param {Object} payload of action/mutator
 * @param {Object} result 
 * @param {boolean} subcall 
 */
export function pluginEmit(type, store, key, payload, result, subcall) {

	const msg = { type, store, key, payload, result, subcall }

	// const callbacksJON = listeners["*"]?.["*"]
	// if (callbacksJON) {
	// 	for (const callback of callbacksJON) callback(msg)
	// }

	if ( !listeners.has(store) ) return

	const storeActions = listeners.get(store)
	if (!storeActions) return

	const callbacksStoreJolly = storeActions["*"]
	if (callbacksStoreJolly) {
		for (const callback of callbacksStoreJolly) callback(msg)
	}

	// get all callbacks for the store and execute them
	const callbacks = storeActions[key]
	if (!callbacks) return
	for (const callback of callbacks) callback(msg)
}


/**
 * Inserts a listener into JON
 * @param {Listener} param0 
 */
export function addWatch({ store, actionName, callback }) {

	let storeActions

	// get or create storeActions
	if (!listeners.has(store)) {
		storeActions = {}
		listeners.set(store, storeActions)
	} else {
		storeActions = listeners.get(store)
	}

	// get or create action
	let callbacks = storeActions[actionName]
	if (!callbacks) {
		callbacks = new Set()
		storeActions[actionName] = callbacks
	}

	callbacks.add(callback)
}

/**
 * removes a listener from JON
 * @param {Listener} param0 
 */
export function removeWatch({ store, actionName, callback }) {

	// if exist get storeActions
	if ( !listeners.has(store) ) return
	const storeActions = listeners.get(store)

	// delete callback from storeActions
	const callbacks = storeActions[actionName]
	if ( callbacks ) callbacks.delete(callback)

	// if there are no more callbacks for the store, delete the storeActions
	if ( !callbacks || callbacks.size === 0) {
		delete storeActions[actionName]
	}
	if (Object.keys(storeActions).length === 0) {
		listeners.delete(store)
	}

}